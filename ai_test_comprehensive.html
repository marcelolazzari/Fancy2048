<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fancy2048 - AI System Deep Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: #fff; }
        .test-section { margin: 20px 0; padding: 20px; background: rgba(42, 42, 42, 0.95); border-radius: 8px; }
        .test-result { margin: 8px 0; padding: 8px 12px; border-radius: 4px; border-left: 4px solid #333; }
        .pass { border-left-color: #4CAF50; background: rgba(76, 175, 80, 0.1); }
        .fail { border-left-color: #f44336; background: rgba(244, 67, 54, 0.1); }
        .warning { border-left-color: #ff9800; background: rgba(255, 152, 0, 0.1); }
        button { background: #ff9900; border: none; padding: 12px 24px; color: white; border-radius: 5px; margin: 8px; cursor: pointer; font-size: 14px; }
        button:hover { background: #ffb300; }
        .ai-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0; }
        .stat-card { background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; }
        .hidden-game { position: absolute; left: -9999px; width: 1px; height: 1px; }
        #console { background: #000; color: #0f0; padding: 15px; font-family: monospace; border-radius: 5px; height: 300px; overflow-y: auto; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>ü§ñ Fancy2048 - AI System Deep Test Suite</h1>
    
    <div class="test-section">
        <h2>üß™ AI Component Tests</h2>
        <button onclick="testAIClassesLoading()">Test AI Classes Loading</button>
        <button onclick="testAIMethods()">Test AI Methods</button>
        <button onclick="testAIIntegration()">Test Game Integration</button>
        <button onclick="benchmarkAIPerformance()">Benchmark Performance</button>
    </div>
    
    <div class="test-section">
        <h2>üéÆ AI Gameplay Tests</h2>
        <button onclick="testAIGameplay()">Test AI Gameplay</button>
        <button onclick="compareAISystems()">Compare AI Systems</button>
        <button onclick="testLearningSystem()">Test Learning System</button>
        <button onclick="runFullAITest()">üöÄ Run All AI Tests</button>
    </div>
    
    <div class="test-section">
        <h2>üìä AI Statistics</h2>
        <div class="ai-stats" id="ai-stats"></div>
    </div>
    
    <div class="test-section">
        <h2>üñ•Ô∏è Test Console</h2>
        <div id="console"></div>
        <button onclick="clearConsole()">Clear Console</button>
    </div>
    
    <div id="test-results"></div>
    
    <!-- Hidden game elements -->
    <div class="hidden-game">
        <div id="score-container"><ul><li>Score: <span id="score">0</span></li></ul></div>
        <div id="board-container"></div>
        <button id="reset-button">Reset</button>
    </div>

    <!-- Load AI scripts -->
    <script src="scripts/ai_learning_system.js"></script>
    <script src="scripts/enhanced_ai.js"></script>
    <script src="scripts/advanced_ai_solver.js"></script>
    <script src="scripts/game.js"></script>

    <script>
        let game = null;
        let aiInstances = {};
        let testResults = {};
        
        function logToConsole(message, type = 'info') {
            const console = document.getElementById('console');
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                'info': '#0f0',
                'error': '#f44',
                'warning': '#ff4',
                'success': '#4f4'
            };
            
            const div = document.createElement('div');
            div.style.color = colors[type] || '#0f0';
            div.textContent = `[${timestamp}] ${message}`;
            console.appendChild(div);
            console.scrollTop = console.scrollHeight;
        }
        
        function clearConsole() {
            document.getElementById('console').innerHTML = '';
        }
        
        function logResult(test, result, message, details = null) {
            testResults[test] = { result, message, details, timestamp: new Date().toISOString() };
            
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${result}`;
            resultDiv.innerHTML = `<strong>${test}:</strong> ${message}`;
            if (details) {
                resultDiv.innerHTML += `<br><small>${details}</small>`;
            }
            document.getElementById('test-results').appendChild(resultDiv);
            
            logToConsole(`${test}: ${message}`, result === 'pass' ? 'success' : result === 'fail' ? 'error' : 'warning');
        }
        
        async function initializeGame() {
            try {
                if (typeof Game === 'undefined') {
                    throw new Error('Game class not loaded');
                }
                
                game = new Game(4);
                game.initializeGame();
                logToConsole('Game engine initialized successfully', 'success');
                return true;
            } catch (error) {
                logToConsole(`Game initialization failed: ${error.message}`, 'error');
                return false;
            }
        }
        
        async function testAIClassesLoading() {
            logToConsole('Testing AI classes loading...', 'info');
            
            const aiClasses = [
                { name: 'Enhanced AI', class: 'Enhanced2048AI' },
                { name: 'Advanced AI Solver', class: 'AdvancedAI2048Solver' },
                { name: 'AI Learning System', class: 'AILearningSystem' }
            ];
            
            let loadedCount = 0;
            
            for (let aiClass of aiClasses) {
                try {
                    if (typeof window[aiClass.class] === 'function') {
                        const ai = new window[aiClass.class](game);
                        aiInstances[aiClass.class] = ai;
                        
                        logResult(`AI Loading: ${aiClass.name}`, 'pass', 'Class loaded and instantiated successfully');
                        loadedCount++;
                    } else {
                        logResult(`AI Loading: ${aiClass.name}`, 'fail', `Class ${aiClass.class} not available globally`);
                    }
                } catch (error) {
                    logResult(`AI Loading: ${aiClass.name}`, 'fail', `Instantiation failed: ${error.message}`);
                }
            }
            
            updateAIStats('Classes Loaded', `${loadedCount}/${aiClasses.length}`);
            return loadedCount === aiClasses.length;
        }
        
        async function testAIMethods() {
            logToConsole('Testing AI methods...', 'info');
            
            const methodTests = [
                { class: 'Enhanced2048AI', methods: ['getBestMove', 'evaluateBoard', 'minimax'] },
                { class: 'AdvancedAI2048Solver', methods: ['getBestMove', 'expectimax'] },
                { class: 'AILearningSystem', methods: ['recordMove', 'recordGameEnd', 'getLearnedMoveRecommendation'] }
            ];
            
            let totalMethods = 0;
            let workingMethods = 0;
            
            for (let test of methodTests) {
                const ai = aiInstances[test.class];
                
                if (!ai) {
                    logResult(`AI Methods: ${test.class}`, 'fail', 'AI instance not available');
                    continue;
                }
                
                for (let method of test.methods) {
                    totalMethods++;
                    
                    if (typeof ai[method] === 'function') {
                        try {
                            // Test method call (with safe parameters)
                            if (method === 'getBestMove') {
                                const move = ai.getBestMove();
                                if (move && ['up', 'down', 'left', 'right'].includes(move)) {
                                    logResult(`Method: ${test.class}.${method}`, 'pass', `Method working, returned: ${move}`);
                                    workingMethods++;
                                } else {
                                    logResult(`Method: ${test.class}.${method}`, 'warning', `Method exists but returned unexpected value: ${move}`);
                                }
                            } else {
                                logResult(`Method: ${test.class}.${method}`, 'pass', 'Method exists and callable');
                                workingMethods++;
                            }
                        } catch (error) {
                            logResult(`Method: ${test.class}.${method}`, 'warning', `Method exists but throws error: ${error.message}`);
                        }
                    } else {
                        logResult(`Method: ${test.class}.${method}`, 'fail', 'Method not found or not a function');
                    }
                }
            }
            
            updateAIStats('Methods Working', `${workingMethods}/${totalMethods}`);
            return workingMethods >= totalMethods * 0.8; // 80% success rate
        }
        
        async function testAIIntegration() {
            logToConsole('Testing AI integration with game...', 'info');
            
            if (!game) {
                await initializeGame();
            }
            
            let integrationTests = 0;
            let passedTests = 0;
            
            // Test Enhanced AI integration
            if (aiInstances.Enhanced2048AI) {
                integrationTests++;
                try {
                    const move = aiInstances.Enhanced2048AI.getBestMove();
                    if (move && game.canMove && game.canMove(move)) {
                        game.move(move);
                        logResult('AI Integration: Enhanced AI', 'pass', `Successfully executed AI move: ${move}`);
                        passedTests++;
                    } else {
                        logResult('AI Integration: Enhanced AI', 'warning', 'AI generated move but execution uncertain');
                    }
                } catch (error) {
                    logResult('AI Integration: Enhanced AI', 'fail', `Integration failed: ${error.message}`);
                }
            }
            
            // Test Advanced AI integration
            if (aiInstances.AdvancedAI2048Solver) {
                integrationTests++;
                try {
                    const move = aiInstances.AdvancedAI2048Solver.getBestMove();
                    if (move) {
                        logResult('AI Integration: Advanced AI', 'pass', `Advanced AI generated move: ${move}`);
                        passedTests++;
                    } else {
                        logResult('AI Integration: Advanced AI', 'fail', 'Advanced AI did not generate a move');
                    }
                } catch (error) {
                    logResult('AI Integration: Advanced AI', 'fail', `Advanced AI integration failed: ${error.message}`);
                }
            }
            
            // Test Learning System integration
            if (aiInstances.AILearningSystem) {
                integrationTests++;
                try {
                    // Test learning system methods
                    aiInstances.AILearningSystem.recordMove(game.board, 'right', game.board, 0);
                    logResult('AI Integration: Learning System', 'pass', 'Learning system can record moves');
                    passedTests++;
                } catch (error) {
                    logResult('AI Integration: Learning System', 'fail', `Learning system failed: ${error.message}`);
                }
            }
            
            updateAIStats('Integration Tests', `${passedTests}/${integrationTests}`);
            return passedTests >= integrationTests * 0.8;
        }
        
        async function benchmarkAIPerformance() {
            logToConsole('Benchmarking AI performance...', 'info');
            
            const benchmarks = {};
            
            for (let [className, ai] of Object.entries(aiInstances)) {
                if (ai && typeof ai.getBestMove === 'function') {
                    const startTime = performance.now();
                    
                    try {
                        for (let i = 0; i < 10; i++) {
                            ai.getBestMove();
                        }
                        
                        const endTime = performance.now();
                        const avgTime = ((endTime - startTime) / 10).toFixed(2);
                        
                        benchmarks[className] = avgTime;
                        logResult(`AI Performance: ${className}`, 'pass', `Average decision time: ${avgTime}ms`);
                        
                    } catch (error) {
                        benchmarks[className] = 'Error';
                        logResult(`AI Performance: ${className}`, 'fail', `Benchmark failed: ${error.message}`);
                    }
                }
            }
            
            // Find fastest AI
            const times = Object.values(benchmarks).filter(t => t !== 'Error').map(t => parseFloat(t));
            if (times.length > 0) {
                const fastest = Math.min(...times);
                updateAIStats('Fastest AI', `${fastest}ms`);
            }
            
            updateAIStats('Performance Results', JSON.stringify(benchmarks, null, 2));
        }
        
        async function testAIGameplay() {
            logToConsole('Testing AI gameplay simulation...', 'info');
            
            if (!game) {
                await initializeGame();
            }
            
            // Reset game for clean test
            game.resetGame();
            
            let movesPlayed = 0;
            let maxMoves = 20;
            
            // Test Enhanced AI gameplay
            if (aiInstances.Enhanced2048AI) {
                for (let i = 0; i < maxMoves; i++) {
                    try {
                        const move = aiInstances.Enhanced2048AI.getBestMove();
                        if (move && game.canMove && game.canMove(move)) {
                            game.move(move);
                            movesPlayed++;
                        } else {
                            break;
                        }
                        
                        if (game.isGameOver && game.isGameOver()) {
                            break;
                        }
                    } catch (error) {
                        logResult('AI Gameplay Test', 'fail', `Gameplay failed at move ${i}: ${error.message}`);
                        break;
                    }
                }
                
                logResult('AI Gameplay Test', 'pass', `AI played ${movesPlayed} moves successfully. Final score: ${game.score || 'N/A'}`);
                updateAIStats('Moves Played', movesPlayed);
                updateAIStats('Final Score', game.score || 0);
            }
        }
        
        async function compareAISystems() {
            logToConsole('Comparing AI systems...', 'info');
            
            const comparison = {};
            
            for (let [className, ai] of Object.entries(aiInstances)) {
                if (ai && typeof ai.getBestMove === 'function') {
                    // Test multiple scenarios
                    const moves = [];
                    for (let i = 0; i < 5; i++) {
                        try {
                            const move = ai.getBestMove();
                            moves.push(move);
                        } catch (error) {
                            moves.push('Error');
                        }
                    }
                    
                    comparison[className] = {
                        moves: moves,
                        consistency: new Set(moves).size <= 2 ? 'High' : 'Variable',
                        reliability: moves.filter(m => ['up', 'down', 'left', 'right'].includes(m)).length / moves.length
                    };
                }
            }
            
            logResult('AI Comparison', 'pass', 'AI systems compared successfully');
            updateAIStats('AI Comparison', JSON.stringify(comparison, null, 2));
        }
        
        async function testLearningSystem() {
            logToConsole('Testing AI learning system...', 'info');
            
            if (!aiInstances.AILearningSystem) {
                logResult('Learning System Test', 'fail', 'Learning system not available');
                return false;
            }
            
            const learningAI = aiInstances.AILearningSystem;
            
            try {
                // Test learning data save/load
                learningAI.saveLearningData();
                learningAI.loadLearningData();
                
                // Test game recording
                learningAI.recordGameEnd(1000, 512, false, 50);
                
                logResult('Learning System Test', 'pass', 'Learning system functions working');
                updateAIStats('Learning System', 'Active');
                return true;
                
            } catch (error) {
                logResult('Learning System Test', 'fail', `Learning system failed: ${error.message}`);
                updateAIStats('Learning System', 'Failed');
                return false;
            }
        }
        
        async function runFullAITest() {
            logToConsole('Running full AI test suite...', 'info');
            document.getElementById('test-results').innerHTML = '';
            
            const startTime = performance.now();
            
            // Initialize game first
            await initializeGame();
            
            // Run all tests
            const loadingTest = await testAIClassesLoading();
            const methodsTest = await testAIMethods();
            const integrationTest = await testAIIntegration();
            const performanceTest = await benchmarkAIPerformance();
            const gameplayTest = await testAIGameplay();
            const comparisonTest = await compareAISystems();
            const learningTest = await testLearningSystem();
            
            const endTime = performance.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);
            
            // Calculate overall results
            const tests = [loadingTest, methodsTest, integrationTest, performanceTest, gameplayTest, comparisonTest, learningTest];
            const passedTests = tests.filter(t => t === true).length;
            const totalTests = tests.length;
            
            // Generate summary
            const summary = {
                totalTests,
                passedTests,
                failedTests: totalTests - passedTests,
                duration: duration + 's',
                overallStatus: passedTests >= totalTests * 0.7 ? 'PASS' : 'FAIL'
            };
            
            updateAIStats('Test Summary', JSON.stringify(summary, null, 2));
            
            logToConsole(`AI Test Suite Complete: ${passedTests}/${totalTests} tests passed in ${duration}s`, 
                        summary.overallStatus === 'PASS' ? 'success' : 'error');
            
            // Send results back to Python if possible
            fetch('/ai-test-results', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ testResults, summary })
            }).catch(e => logToConsole('Could not send results to Python test suite', 'warning'));
        }
        
        function updateAIStats(label, value) {
            const statsContainer = document.getElementById('ai-stats');
            const statCard = document.createElement('div');
            statCard.className = 'stat-card';
            statCard.innerHTML = `<strong>${label}:</strong><br>${value}`;
            statsContainer.appendChild(statCard);
        }
        
        // Auto-initialize when page loads
        window.addEventListener('load', () => {
            logToConsole('AI Test Suite Loaded', 'success');
            setTimeout(initializeGame, 1000);
        });
    </script>
</body>
</html>