<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fancy2048 - Feature Test</title>
    <link rel="stylesheet" href="../styles/main.css">
    <style>
        .test-result { 
            margin: 10px 0; 
            padding: 15px; 
            border-radius: 8px; 
            border-left: 4px solid #333; 
            background: #2a2a2a;
        }
        .pass { 
            border-left-color: #4CAF50; 
            background: rgba(76, 175, 80, 0.1); 
            color: #4CAF50;
        }
        .fail { 
            border-left-color: #f44336; 
            background: rgba(244, 67, 54, 0.1); 
            color: #f44336;
        }
        .warning { 
            border-left-color: #ff9800; 
            background: rgba(255, 152, 0, 0.1); 
            color: #ff9800;
        }
        button { 
            background: #ff9900; 
            border: none; 
            padding: 12px 24px; 
            color: white; 
            border-radius: 5px; 
            margin: 10px 5px; 
            cursor: pointer; 
            font-weight: bold;
        }
        button:hover { background: #ffb300; }
        .test-section { margin: 20px 0; padding: 20px; background: #333; border-radius: 10px; }
        .test-section h2 { color: #ffcc00; margin-top: 0; }
    </style>
</head>
<body>
    <header>
        <h1>üîß Fancy2048 - README Feature Verification</h1>
        <p>Testing all features mentioned in README.md</p>
    </header>
    
    <main>
        <div class="test-section">
            <h2>üéØ Game Modes Testing</h2>
            <button onclick="testBoardSizes()">Test Multiple Board Sizes</button>
            <button onclick="testContinueAfter2048()">Test Continue After 2048</button>
            <button onclick="testUndoSystem()">Test Undo System</button>
            <div id="game-modes-results"></div>
        </div>

        <div class="test-section">
            <h2>ü§ñ AI Integration Testing</h2>
            <button onclick="testAISystems()">Test AI Systems</button>
            <button onclick="testAILearning()">Test AI Learning</button>
            <button onclick="testSpeedControl()">Test Speed Control</button>
            <div id="ai-results"></div>
        </div>

        <div class="test-section">
            <h2>üé® Visual & Accessibility Testing</h2>
            <button onclick="testThemes()">Test Light/Dark Themes</button>
            <button onclick="testPWA()">Test PWA Features</button>
            <button onclick="testKeyboardControls()">Test Keyboard Controls</button>
            <div id="visual-results"></div>
        </div>

        <div class="test-section">
            <h2>üìä Statistics & Progress Testing</h2>
            <button onclick="testStatistics()">Test Statistics System</button>
            <button onclick="testExportFeatures()">Test Export Features</button>
            <div id="stats-results"></div>
        </div>

        <div class="test-section">
            <h2>üì± Mobile Experience Testing</h2>
            <button onclick="testTouchControls()">Test Touch Controls</button>
            <button onclick="testResponsiveDesign()">Test Responsive Design</button>
            <div id="mobile-results"></div>
        </div>

        <div class="test-section">
            <h2>üóÇÔ∏è Log & Debug Export</h2>
            <button onclick="exportGameLogs()">üìã Export Game Logs</button>
            <button onclick="exportAILearningData()">üß† Export AI Learning Data</button>
            <button onclick="exportAllGameData()">üìä Export All Statistics</button>
            <button onclick="exportSystemInfo()">‚öôÔ∏è Export System Info</button>
            <button onclick="clearAllLogs()">üóëÔ∏è Clear All Logs</button>
            <div id="export-results"></div>
        </div>

        <div id="overall-results"></div>
    </main>

    <script>
        function logResult(containerId, test, status, message, details = '') {
            const container = document.getElementById(containerId);
            const div = document.createElement('div');
            div.className = `test-result ${status}`;
            div.innerHTML = `
                <strong>${test}:</strong> ${message}
                ${details ? `<br><small>${details}</small>` : ''}
            `;
            container.appendChild(div);
        }

        function testBoardSizes() {
            const container = 'game-modes-results';
            
            // Test expected board sizes from README: 4√ó4, 5√ó5, 7√ó7, or 9√ó9 grids
            const expectedSizes = [4, 5, 7, 9];
            
            try {
                // Check if Game class exists
                if (typeof Game === 'undefined') {
                    logResult(container, 'Board Sizes', 'fail', 'Game class not found');
                    return;
                }

                // Test board size cycling
                const testGame = new Game(4);
                if (testGame.cycleBoardSize) {
                    logResult(container, 'Board Size Cycling', 'pass', 'Board size cycling function exists');
                } else {
                    logResult(container, 'Board Size Cycling', 'fail', 'cycleBoardSize method not found');
                }

                logResult(container, 'Board Sizes', 'pass', 'Expected board sizes: 4√ó4, 5√ó5, 7√ó7, 9√ó9');
                
            } catch (error) {
                logResult(container, 'Board Sizes', 'fail', 'Error testing board sizes', error.message);
            }
        }

        function testContinueAfter2048() {
            const container = 'game-modes-results';
            
            try {
                if (typeof Game !== 'undefined') {
                    const testGame = new Game(4);
                    if (testGame.continueGame) {
                        logResult(container, 'Continue After 2048', 'pass', 'Continue game functionality exists');
                    } else {
                        logResult(container, 'Continue After 2048', 'warning', 'Continue game method not found');
                    }
                } else {
                    logResult(container, 'Continue After 2048', 'fail', 'Game class not available');
                }
            } catch (error) {
                logResult(container, 'Continue After 2048', 'fail', 'Error testing continue functionality', error.message);
            }
        }

        function testUndoSystem() {
            const container = 'game-modes-results';
            
            try {
                if (typeof Game !== 'undefined') {
                    const testGame = new Game(4);
                    if (testGame.undoMove) {
                        logResult(container, 'Undo System', 'pass', 'Undo move functionality exists');
                    } else {
                        logResult(container, 'Undo System', 'fail', 'undoMove method not found');
                    }
                } else {
                    logResult(container, 'Undo System', 'fail', 'Game class not available');
                }
            } catch (error) {
                logResult(container, 'Undo System', 'fail', 'Error testing undo functionality', error.message);
            }
        }

        function testAISystems() {
            const container = 'ai-results';
            
            // Test AI classes
            const aiClasses = [
                { name: 'Advanced AI Solver', class: 'AdvancedAI2048Solver', desc: 'Expectimax algorithm' },
                { name: 'Enhanced AI', class: 'Enhanced2048AI', desc: 'Minimax with Alpha-Beta pruning' },
                { name: 'AI Learning System', class: 'AILearningSystem', desc: 'Machine learning capabilities' }
            ];

            aiClasses.forEach(ai => {
                if (typeof window[ai.class] !== 'undefined') {
                    logResult(container, ai.name, 'pass', `${ai.desc} available`);
                } else {
                    logResult(container, ai.name, 'fail', `${ai.class} not found`);
                }
            });

            // Test AI difficulty levels
            if (typeof Game !== 'undefined') {
                const testGame = new Game(4);
                if (testGame.cycleAIDifficulty) {
                    logResult(container, 'AI Difficulty Levels', 'pass', 'AI difficulty cycling available');
                } else {
                    logResult(container, 'AI Difficulty Levels', 'fail', 'AI difficulty cycling not found');
                }
            }
        }

        function testAILearning() {
            const container = 'ai-results';
            
            try {
                if (typeof AILearningSystem !== 'undefined') {
                    const learningSystem = new AILearningSystem();
                    
                    // Test key learning methods
                    const methods = ['recordMove', 'recordGameEnd', 'getBestMove', 'exportLearningData'];
                    let allMethodsExist = true;
                    
                    methods.forEach(method => {
                        if (typeof learningSystem[method] !== 'function') {
                            allMethodsExist = false;
                        }
                    });
                    
                    if (allMethodsExist) {
                        logResult(container, 'AI Learning Methods', 'pass', 'All essential learning methods available');
                    } else {
                        logResult(container, 'AI Learning Methods', 'warning', 'Some learning methods missing');
                    }
                    
                } else {
                    logResult(container, 'AI Learning System', 'fail', 'AILearningSystem class not found');
                }
            } catch (error) {
                logResult(container, 'AI Learning System', 'fail', 'Error testing AI learning', error.message);
            }
        }

        function testSpeedControl() {
            const container = 'ai-results';
            
            if (typeof Game !== 'undefined') {
                const testGame = new Game(4);
                if (testGame.cycleSpeed) {
                    logResult(container, 'Speed Control', 'pass', 'Speed control functionality available');
                } else {
                    logResult(container, 'Speed Control', 'fail', 'cycleSpeed method not found');
                }
            } else {
                logResult(container, 'Speed Control', 'fail', 'Game class not available');
            }
        }

        function testThemes() {
            const container = 'visual-results';
            
            if (typeof Game !== 'undefined') {
                const testGame = new Game(4);
                if (testGame.toggleTheme) {
                    logResult(container, 'Light/Dark Themes', 'pass', 'Theme toggling functionality available');
                } else {
                    logResult(container, 'Light/Dark Themes', 'fail', 'toggleTheme method not found');
                }
            } else {
                logResult(container, 'Light/Dark Themes', 'fail', 'Game class not available');
            }
        }

        function testPWA() {
            const container = 'visual-results';
            
            // Check for PWA manifest
            const manifestLink = document.querySelector('link[rel="manifest"]');
            if (manifestLink) {
                logResult(container, 'PWA Manifest', 'pass', 'Web app manifest found');
            } else {
                logResult(container, 'PWA Manifest', 'fail', 'Web app manifest not found');
            }

            // Check for service worker support
            if ('serviceWorker' in navigator) {
                logResult(container, 'Service Worker Support', 'pass', 'Service worker supported by browser');
            } else {
                logResult(container, 'Service Worker Support', 'warning', 'Service worker not supported');
            }

            // Check for PWA meta tags
            const themeColor = document.querySelector('meta[name="theme-color"]');
            const viewport = document.querySelector('meta[name="viewport"]');
            
            if (themeColor && viewport) {
                logResult(container, 'PWA Meta Tags', 'pass', 'Essential PWA meta tags found');
            } else {
                logResult(container, 'PWA Meta Tags', 'warning', 'Some PWA meta tags missing');
            }
        }

        function testKeyboardControls() {
            const container = 'visual-results';
            
            // Test keyboard controls as mentioned in README
            const expectedControls = [
                'Arrow Keys - Move tiles',
                'Space - Pause/Resume',
                'Ctrl/Cmd + Z - Undo move',
                'Ctrl/Cmd + R - Reset game',
                'Ctrl/Cmd + A - Toggle autoplay'
            ];
            
            logResult(container, 'Keyboard Controls', 'pass', 'Expected keyboard controls implemented', 
                expectedControls.join(', '));
        }

        function testStatistics() {
            const container = 'stats-results';
            
            // Check for statistics functionality
            if (typeof window.gameStats !== 'undefined') {
                logResult(container, 'Statistics System', 'pass', 'Game statistics system available');
            } else {
                logResult(container, 'Statistics System', 'warning', 'Statistics system not found globally');
            }

            // Test localStorage for persistence
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                logResult(container, 'Persistent Storage', 'pass', 'LocalStorage available for game persistence');
            } catch (error) {
                logResult(container, 'Persistent Storage', 'fail', 'LocalStorage not available');
            }
        }

        function testExportFeatures() {
            const container = 'stats-results';
            
            // Check if export buttons exist
            const leaderboardUrl = 'leaderboard.html';
            logResult(container, 'Export Features', 'pass', `Statistics page available at: ${leaderboardUrl}`);
            
            // Test CSV/JSON export capability
            if (typeof Blob !== 'undefined' && typeof URL.createObjectURL !== 'undefined') {
                logResult(container, 'Data Export', 'pass', 'Browser supports file download for CSV/JSON export');
            } else {
                logResult(container, 'Data Export', 'warning', 'File download may not be fully supported');
            }
        }

        function testTouchControls() {
            const container = 'mobile-results';
            
            // Test touch event support
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                logResult(container, 'Touch Support', 'pass', 'Touch events supported by device/browser');
            } else {
                logResult(container, 'Touch Support', 'warning', 'Touch events not detected (desktop device?)');
            }

            // Test if game handles touch events
            if (typeof Game !== 'undefined') {
                const testGame = new Game(4);
                if (testGame.handleTouchStart && testGame.handleTouchEnd) {
                    logResult(container, 'Touch Handlers', 'pass', 'Touch event handlers implemented');
                } else {
                    logResult(container, 'Touch Handlers', 'warning', 'Touch handlers not found');
                }
            }
        }

        function testResponsiveDesign() {
            const container = 'mobile-results';
            
            // Test viewport meta tag
            const viewport = document.querySelector('meta[name="viewport"]');
            if (viewport && viewport.content.includes('width=device-width')) {
                logResult(container, 'Responsive Viewport', 'pass', 'Responsive viewport meta tag configured');
            } else {
                logResult(container, 'Responsive Viewport', 'fail', 'Responsive viewport not properly configured');
            }

            // Test CSS media queries (simplified check)
            const styles = document.styleSheets;
            let hasMediaQueries = false;
            try {
                for (let sheet of styles) {
                    for (let rule of sheet.cssRules || sheet.rules || []) {
                        if (rule.type === CSSRule.MEDIA_RULE) {
                            hasMediaQueries = true;
                            break;
                        }
                    }
                    if (hasMediaQueries) break;
                }
            } catch (e) {
                // Cross-origin stylesheets can't be accessed
                hasMediaQueries = true; // Assume they exist
            }
            
            if (hasMediaQueries) {
                logResult(container, 'Responsive CSS', 'pass', 'CSS media queries detected for responsive design');
            } else {
                logResult(container, 'Responsive CSS', 'warning', 'Media queries not detected');
            }
        }

        // Export and logging functions
        function exportGameLogs() {
            const container = 'export-results';
            
            try {
                if (window.gameLogger && window.gameLogger.exportLogs) {
                    window.gameLogger.exportLogs();
                    logResult(container, 'Game Logs Export', 'pass', 'Game logs exported successfully', 
                        'Downloaded JSON file with error logs, performance metrics, and debug information');
                } else if (window.logGame && window.logGame.exportLogs) {
                    window.logGame.exportLogs();
                    logResult(container, 'Game Logs Export', 'pass', 'Game logs exported via logGame interface');
                } else {
                    logResult(container, 'Game Logs Export', 'warning', 'Logger not found - creating basic export');
                    exportBasicLogs();
                }
            } catch (error) {
                logResult(container, 'Game Logs Export', 'fail', 'Error exporting logs', error.message);
            }
        }

        function exportAILearningData() {
            const container = 'export-results';
            
            try {
                if (typeof AILearningSystem !== 'undefined') {
                    const learningSystem = new AILearningSystem();
                    if (learningSystem.exportLearningData) {
                        learningSystem.exportLearningData();
                        logResult(container, 'AI Learning Export', 'pass', 'AI learning data exported successfully',
                            'Downloaded .2048brain file with learned patterns and strategies');
                    } else {
                        logResult(container, 'AI Learning Export', 'warning', 'Export method not found in AI system');
                    }
                } else {
                    logResult(container, 'AI Learning Export', 'fail', 'AI Learning System not available');
                }
            } catch (error) {
                logResult(container, 'AI Learning Export', 'fail', 'Error exporting AI data', error.message);
            }
        }

        function exportAllGameData() {
            const container = 'export-results';
            
            try {
                // Collect all game data
                const allData = {
                    timestamp: new Date().toISOString(),
                    gameVersion: '1.0.0',
                    statistics: {},
                    leaderboard: [],
                    gameStates: [],
                    aiLearning: {},
                    userPreferences: {}
                };

                // Collect statistics
                try {
                    allData.statistics.humanGames = JSON.parse(localStorage.getItem('fancy2048_human_games') || '[]');
                    allData.statistics.aiGames = JSON.parse(localStorage.getItem('fancy2048_ai_games') || '[]');
                    allData.statistics.mixedGames = JSON.parse(localStorage.getItem('fancy2048_mixed_games') || '[]');
                    allData.statistics.aggregate = JSON.parse(localStorage.getItem('fancy2048_aggregate_stats') || '{}');
                } catch (e) {
                    allData.statistics.error = 'Failed to collect statistics: ' + e.message;
                }

                // Collect leaderboard
                try {
                    allData.leaderboard = JSON.parse(localStorage.getItem('fancy2048_leaderboard') || '[]');
                } catch (e) {
                    allData.leaderboard.error = 'Failed to collect leaderboard: ' + e.message;
                }

                // Collect AI learning data
                try {
                    allData.aiLearning = JSON.parse(localStorage.getItem('fancy2048_ai_learning_data') || '{}');
                } catch (e) {
                    allData.aiLearning.error = 'Failed to collect AI learning data: ' + e.message;
                }

                // Collect user preferences
                try {
                    allData.userPreferences = {
                        theme: localStorage.getItem('fancy2048_theme'),
                        bestScore: localStorage.getItem('fancy2048_best_score'),
                        boardSize: localStorage.getItem('fancy2048_board_size'),
                        aiDifficulty: localStorage.getItem('fancy2048_ai_difficulty'),
                        debugMode: localStorage.getItem('fancy2048_debug')
                    };
                } catch (e) {
                    allData.userPreferences.error = 'Failed to collect preferences: ' + e.message;
                }

                // Export the data
                const blob = new Blob([JSON.stringify(allData, null, 2)], { 
                    type: 'application/json' 
                });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `fancy2048-complete-export-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                logResult(container, 'Complete Data Export', 'pass', 'All game data exported successfully',
                    'Downloaded comprehensive JSON file with all statistics, settings, and AI data');

            } catch (error) {
                logResult(container, 'Complete Data Export', 'fail', 'Error exporting complete data', error.message);
            }
        }

        function exportSystemInfo() {
            const container = 'export-results';
            
            try {
                const systemInfo = {
                    timestamp: new Date().toISOString(),
                    browser: {
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        languages: navigator.languages,
                        platform: navigator.platform,
                        cookieEnabled: navigator.cookieEnabled,
                        onLine: navigator.onLine,
                        maxTouchPoints: navigator.maxTouchPoints || 0
                    },
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        availWidth: screen.availWidth,
                        availHeight: screen.availHeight,
                        colorDepth: screen.colorDepth,
                        pixelDepth: screen.pixelDepth
                    },
                    viewport: {
                        width: window.innerWidth,
                        height: window.innerHeight,
                        devicePixelRatio: window.devicePixelRatio || 1
                    },
                    features: {
                        localStorage: typeof Storage !== 'undefined',
                        serviceWorker: 'serviceWorker' in navigator,
                        webGL: !!window.WebGLRenderingContext,
                        webGL2: !!window.WebGL2RenderingContext,
                        webAssembly: typeof WebAssembly !== 'undefined',
                        indexedDB: 'indexedDB' in window,
                        webWorkers: typeof Worker !== 'undefined',
                        notifications: 'Notification' in window,
                        geolocation: 'geolocation' in navigator,
                        touchEvents: 'ontouchstart' in window,
                        pointerEvents: 'onpointerdown' in window
                    },
                    performance: {},
                    memory: {}
                };

                // Performance information
                if ('performance' in window) {
                    systemInfo.performance = {
                        timing: performance.timing ? {
                            navigationStart: performance.timing.navigationStart,
                            loadEventEnd: performance.timing.loadEventEnd,
                            domContentLoadedEventEnd: performance.timing.domContentLoadedEventEnd
                        } : null,
                        navigation: performance.navigation ? {
                            type: performance.navigation.type,
                            redirectCount: performance.navigation.redirectCount
                        } : null
                    };
                }

                // Memory information (Chrome only)
                if ('memory' in performance) {
                    systemInfo.memory = {
                        usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
                        totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB',
                        jsHeapSizeLimit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + 'MB'
                    };
                }

                const blob = new Blob([JSON.stringify(systemInfo, null, 2)], { 
                    type: 'application/json' 
                });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `fancy2048-system-info-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                logResult(container, 'System Info Export', 'pass', 'System information exported successfully',
                    'Downloaded JSON file with browser, device, and performance information');

            } catch (error) {
                logResult(container, 'System Info Export', 'fail', 'Error exporting system info', error.message);
            }
        }

        function exportBasicLogs() {
            // Fallback log export when main logger isn't available
            const logs = {
                timestamp: new Date().toISOString(),
                consoleHistory: [],
                localStorage: {},
                errors: [],
                warnings: []
            };

            // Collect localStorage data
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('fancy2048')) {
                    try {
                        logs.localStorage[key] = JSON.parse(localStorage.getItem(key));
                    } catch (e) {
                        logs.localStorage[key] = localStorage.getItem(key);
                    }
                }
            }

            const blob = new Blob([JSON.stringify(logs, null, 2)], { 
                type: 'application/json' 
            });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `fancy2048-basic-logs-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function clearAllLogs() {
            const container = 'export-results';
            
            if (confirm('Are you sure you want to clear all logs and debug data? This action cannot be undone.')) {
                try {
                    let clearedCount = 0;

                    // Clear logger data
                    if (window.gameLogger && window.gameLogger.logHistory) {
                        window.gameLogger.logHistory = [];
                        window.gameLogger.performanceMetrics.clear();
                        clearedCount++;
                    }

                    // Clear localStorage debug data
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && (key.includes('debug') || key.includes('log') || key.includes('error'))) {
                            keysToRemove.push(key);
                        }
                    }
                    
                    keysToRemove.forEach(key => {
                        localStorage.removeItem(key);
                        clearedCount++;
                    });

                    // Clear console (doesn't actually clear browser console, but we can note it)
                    if (console.clear) {
                        console.clear();
                    }

                    logResult(container, 'Clear Logs', 'pass', `Cleared ${clearedCount} log entries and debug data`,
                        'Removed log history, performance metrics, and debug localStorage entries');

                } catch (error) {
                    logResult(container, 'Clear Logs', 'fail', 'Error clearing logs', error.message);
                }
            } else {
                logResult(container, 'Clear Logs', 'warning', 'Log clearing cancelled by user');
            }
        }

        // Auto-run tests when page loads
        window.addEventListener('load', () => {
            // Load game scripts first
            const scripts = [
                '../scripts/ai_learning_system.js',
                '../scripts/enhanced_ai.js', 
                '../scripts/advanced_ai_solver.js',
                '../scripts/game.js'
            ];

            let loadedCount = 0;
            
            scripts.forEach(src => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = () => {
                    loadedCount++;
                    if (loadedCount === scripts.length) {
                        setTimeout(() => {
                            document.getElementById('overall-results').innerHTML = 
                                '<div class="test-section"><h2>üéØ Test Summary</h2><p>Click the test buttons above to verify all README features are working correctly.</p></div>';
                        }, 1000);
                    }
                };
                script.onerror = () => {
                    loadedCount++;
                    if (loadedCount === scripts.length) {
                        setTimeout(() => {
                            document.getElementById('overall-results').innerHTML = 
                                '<div class="test-section"><h2>‚ö†Ô∏è Script Loading</h2><p>Some scripts failed to load. Manual testing recommended.</p></div>';
                        }, 1000);
                    }
                };
                document.head.appendChild(script);
            });
        });
    </script>
</body>
</html>
