<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fancy2048 - Score Dashboard Testing Suite</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: #fff; }
        .test-header { text-align: center; margin: 20px 0; padding: 20px; background: rgba(42, 42, 42, 0.95); border-radius: 8px; }
        .test-section { margin: 20px 0; padding: 20px; background: rgba(42, 42, 42, 0.95); border-radius: 8px; }
        .test-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0; }
        .game-mode-card { background: rgba(0,0,0,0.3); padding: 20px; border-radius: 8px; border: 2px solid #333; }
        .game-mode-card.active { border-color: #4CAF50; }
        .game-mode-card.testing { border-color: #ff9800; }
        .test-result { margin: 8px 0; padding: 8px; border-radius: 4px; }
        .pass { background: rgba(76, 175, 80, 0.2); color: #4CAF50; }
        .fail { background: rgba(244, 67, 54, 0.2); color: #f44336; }
        .warning { background: rgba(255, 152, 0, 0.2); color: #ff9800; }
        .info { background: rgba(33, 150, 243, 0.2); color: #2196F3; }
        button { background: #ff9900; border: none; padding: 12px 24px; color: white; border-radius: 5px; margin: 8px; cursor: pointer; font-size: 14px; }
        button:hover { background: #ffb300; }
        button:disabled { background: #666; cursor: not-allowed; }
        .game-simulator { position: relative; margin: 20px 0; }
        .mini-board { display: grid; grid-template-columns: repeat(4, 50px); gap: 3px; margin: 10px 0; }
        .mini-tile { width: 50px; height: 50px; background: #333; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 11px; }
        .console { background: #000; color: #0f0; padding: 15px; font-family: monospace; border-radius: 5px; height: 250px; overflow-y: auto; margin: 10px 0; }
        .stats-display { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin: 10px 0; }
        .stat-card { text-align: center; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 5px; }
        .leaderboard-preview { max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 5px; margin: 10px 0; }
        .score-entry { display: flex; justify-content: space-between; align-items: center; padding: 8px; margin: 4px 0; background: rgba(255,255,255,0.1); border-radius: 4px; }
        .hidden-game { position: absolute; left: -9999px; }
        .progress-bar { width: 100%; height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px; overflow: hidden; margin: 10px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); transition: width 0.3s ease; }
    </style>
</head>
<body>
    <div class="test-header">
        <h1>üèÜ Fancy2048 - Score Dashboard Testing Suite</h1>
        <p>Comprehensive testing of score tracking for Human, AI, and Mixed gameplay</p>
        <div class="progress-bar">
            <div class="progress-fill" id="overall-progress" style="width: 0%"></div>
        </div>
        <button onclick="runFullScoreTest()" style="font-size: 16px; padding: 15px 30px;">üß™ Run Complete Score Dashboard Test</button>
    </div>
    
    <div class="test-section">
        <h2>üéÆ Game Mode Testing</h2>
        <div class="test-grid" id="game-modes">
            <div class="game-mode-card" id="human-mode-card">
                <h3>üë§ Human Player Mode</h3>
                <p>Test score tracking for manual gameplay</p>
                <button onclick="testHumanGameplay()" id="test-human-btn">Test Human Scores</button>
                <div id="human-test-results"></div>
            </div>
            
            <div class="game-mode-card" id="ai-mode-card">
                <h3>ü§ñ AI Player Mode</h3>
                <p>Test score tracking for AI-only gameplay</p>
                <button onclick="testAIGameplay()" id="test-ai-btn">Test AI Scores</button>
                <div id="ai-test-results"></div>
            </div>
            
            <div class="game-mode-card" id="mixed-mode-card">
                <h3>üîÑ Mixed Mode</h3>
                <p>Test score tracking for human + AI gameplay</p>
                <button onclick="testMixedGameplay()" id="test-mixed-btn">Test Mixed Scores</button>
                <div id="mixed-test-results"></div>
            </div>
        </div>
    </div>
    
    <div class="test-section">
        <h2>üìä Score Persistence Testing</h2>
        <div class="game-simulator">
            <button onclick="testScorePersistence()">Test Score Persistence</button>
            <button onclick="testLeaderboardUpdates()">Test Leaderboard Updates</button>
            <button onclick="clearAllScores()">Clear All Test Scores</button>
            <button onclick="generateTestScores()">Generate Test Data</button>
            
            <div class="stats-display" id="persistence-stats"></div>
        </div>
    </div>
    
    <div class="test-section">
        <h2>üèÜ Live Leaderboard Preview</h2>
        <div class="leaderboard-preview" id="leaderboard-preview">
            <p>Loading leaderboard data...</p>
        </div>
        <button onclick="refreshLeaderboard()">Refresh Leaderboard</button>
        <button onclick="exportScoreData()">Export Score Data</button>
    </div>
    
    <div class="test-section">
        <h2>üñ•Ô∏è Test Console</h2>
        <div class="console" id="console"></div>
        <button onclick="clearConsole()">Clear Console</button>
        <button onclick="exportTestResults()">Export Test Results</button>
    </div>
    
    <!-- Hidden game elements for testing -->
    <div class="hidden-game">
        <div id="score-container"><ul><li>Score: <span id="score">0</span></li></ul></div>
        <div id="board-container"></div>
        <button id="reset-button">Reset</button>
    </div>

    <!-- Load game scripts -->
    <script src="scripts/statistics.js"></script>
    <script src="scripts/leaderboard-stats.js"></script>
    <script src="scripts/ai_learning_system.js"></script>
    <script src="scripts/enhanced_ai.js"></script>
    <script src="scripts/advanced_ai_solver.js"></script>
    <script src="scripts/game.js"></script>

    <script>
        let game = null;
        let testResults = {};
        let currentTestProgress = 0;
        let totalTests = 12; // Total number of tests
        
        function log(message, type = 'info') {
            const console = document.getElementById('console');
            const timestamp = new Date().toLocaleTimeString();
            const colors = { info: '#0f0', error: '#f44', warning: '#ff4', success: '#4f4' };
            
            const div = document.createElement('div');
            div.style.color = colors[type] || '#0f0';
            div.innerHTML = `[${timestamp}] ${message}`;
            console.appendChild(div);
            console.scrollTop = console.scrollHeight;
        }
        
        function clearConsole() {
            document.getElementById('console').innerHTML = '';
        }
        
        function updateProgress() {
            currentTestProgress++;
            const percentage = (currentTestProgress / totalTests) * 100;
            document.getElementById('overall-progress').style.width = percentage + '%';
        }
        
        function addTestResult(container, test, success, message) {
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${success ? 'pass' : 'fail'}`;
            resultDiv.innerHTML = `<strong>${test}:</strong> ${message}`;
            document.getElementById(container).appendChild(resultDiv);
            
            testResults[test] = { success, message, timestamp: new Date().toISOString() };
            log(`${test}: ${success ? '‚úÖ' : '‚ùå'} ${message}`, success ? 'success' : 'error');
        }
        
        async function initializeGame() {
            try {
                if (typeof Game === 'undefined') {
                    throw new Error('Game class not found');
                }
                
                game = new Game(4);
                game.initializeGame();
                log('üéÆ Game engine initialized for testing', 'success');
                return true;
            } catch (error) {
                log(`‚ùå Game initialization failed: ${error.message}`, 'error');
                return false;
            }
        }
        
        function simulateGameplay(moves = 10, playerType = 'human') {
            if (!game) return null;
            
            const gameData = {
                startTime: Date.now(),
                moves: [],
                playerType: playerType,
                startScore: game.score || 0
            };
            
            // Reset game for clean test
            game.resetGame();
            
            for (let i = 0; i < moves; i++) {
                const possibleMoves = ['up', 'down', 'left', 'right'];
                const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                
                if (game.canMove && game.canMove(randomMove)) {
                    const oldScore = game.score || 0;
                    game.move(randomMove);
                    const newScore = game.score || 0;
                    
                    gameData.moves.push({
                        move: randomMove,
                        scoreGain: newScore - oldScore,
                        boardState: JSON.parse(JSON.stringify(game.board))
                    });
                }
                
                if (game.gameState === 'gameOver') {
                    break;
                }
            }
            
            gameData.endTime = Date.now();
            gameData.finalScore = game.score || 0;
            gameData.totalMoves = gameData.moves.length;
            gameData.duration = gameData.endTime - gameData.startTime;
            
            return gameData;
        }
        
        async function testHumanGameplay() {
            log('üë§ Testing human gameplay score tracking...', 'info');
            document.getElementById('human-mode-card').className = 'game-mode-card testing';
            
            if (!game) {
                await initializeGame();
            }
            
            // Simulate human gameplay
            const gameData = simulateGameplay(15, 'human');
            
            if (gameData) {
                // Test score saving
                try {
                    // Try to save game data
                    const scoreData = {
                        score: gameData.finalScore,
                        moves: gameData.totalMoves,
                        duration: gameData.duration,
                        playerType: 'human',
                        timestamp: Date.now(),
                        boardSize: 4
                    };
                    
                    // Save to localStorage (simulating game save)
                    let savedGames = JSON.parse(localStorage.getItem('gameStats') || '[]');
                    savedGames.push(scoreData);
                    localStorage.setItem('gameStats', JSON.stringify(savedGames));
                    
                    addTestResult('human-test-results', 'Human Score Save', true, 
                                `Score ${gameData.finalScore} saved successfully`);
                    
                    // Test score retrieval
                    const retrievedGames = JSON.parse(localStorage.getItem('gameStats') || '[]');
                    const lastGame = retrievedGames[retrievedGames.length - 1];
                    
                    if (lastGame && lastGame.score === gameData.finalScore) {
                        addTestResult('human-test-results', 'Human Score Retrieval', true,
                                    'Score retrieved correctly from storage');
                    } else {
                        addTestResult('human-test-results', 'Human Score Retrieval', false,
                                    'Score retrieval mismatch');
                    }
                    
                } catch (error) {
                    addTestResult('human-test-results', 'Human Score Save', false,
                                `Save failed: ${error.message}`);
                }
            } else {
                addTestResult('human-test-results', 'Human Gameplay Simulation', false,
                            'Failed to simulate gameplay');
            }
            
            document.getElementById('human-mode-card').className = 'game-mode-card active';
            updateProgress();
        }
        
        async function testAIGameplay() {
            log('ü§ñ Testing AI gameplay score tracking...', 'info');
            document.getElementById('ai-mode-card').className = 'game-mode-card testing';
            
            if (!game) {
                await initializeGame();
            }
            
            // Test with Enhanced AI
            if (game.enhancedAI) {
                try {
                    const gameData = simulateAIGameplay(10, 'enhanced-ai');
                    
                    if (gameData) {
                        const scoreData = {
                            score: gameData.finalScore,
                            moves: gameData.totalMoves,
                            duration: gameData.duration,
                            playerType: 'ai',
                            aiType: 'enhanced-ai',
                            timestamp: Date.now(),
                            boardSize: 4
                        };
                        
                        // Save AI game data
                        let aiGames = JSON.parse(localStorage.getItem('aiGameStats') || '[]');
                        aiGames.push(scoreData);
                        localStorage.setItem('aiGameStats', JSON.stringify(aiGames));
                        
                        addTestResult('ai-test-results', 'AI Score Save', true,
                                    `AI score ${gameData.finalScore} saved`);
                        
                        // Test AI score categorization
                        const retrievedAIGames = JSON.parse(localStorage.getItem('aiGameStats') || '[]');
                        const aiOnlyGames = retrievedAIGames.filter(g => g.playerType === 'ai');
                        
                        if (aiOnlyGames.length > 0) {
                            addTestResult('ai-test-results', 'AI Score Categorization', true,
                                        `${aiOnlyGames.length} AI games properly categorized`);
                        } else {
                            addTestResult('ai-test-results', 'AI Score Categorization', false,
                                        'AI games not properly categorized');
                        }
                        
                    } else {
                        addTestResult('ai-test-results', 'AI Gameplay Simulation', false,
                                    'Failed to simulate AI gameplay');
                    }
                } catch (error) {
                    addTestResult('ai-test-results', 'AI Score Tracking', false,
                                `AI tracking failed: ${error.message}`);
                }
            } else {
                addTestResult('ai-test-results', 'AI Availability', false,
                            'Enhanced AI not available for testing');
            }
            
            document.getElementById('ai-mode-card').className = 'game-mode-card active';
            updateProgress();
        }
        
        function simulateAIGameplay(moves, aiType) {
            if (!game) return null;
            
            const gameData = {
                startTime: Date.now(),
                moves: [],
                playerType: 'ai',
                aiType: aiType,
                startScore: game.score || 0
            };
            
            game.resetGame();
            
            for (let i = 0; i < moves; i++) {
                let aiMove = null;
                
                // Get AI move based on type
                if (aiType === 'enhanced-ai' && game.enhancedAI) {
                    try {
                        aiMove = game.enhancedAI.getBestMove();
                    } catch (e) {
                        aiMove = null;
                    }
                } else if (aiType === 'advanced-ai' && game.advancedAI) {
                    try {
                        aiMove = game.advancedAI.getBestMove();
                    } catch (e) {
                        aiMove = null;
                    }
                }
                
                // Fallback to random move if AI fails
                if (!aiMove) {
                    const possibleMoves = ['up', 'down', 'left', 'right'];
                    aiMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                }
                
                if (game.canMove && game.canMove(aiMove)) {
                    const oldScore = game.score || 0;
                    game.move(aiMove);
                    const newScore = game.score || 0;
                    
                    gameData.moves.push({
                        move: aiMove,
                        scoreGain: newScore - oldScore,
                        aiGenerated: true
                    });
                }
                
                if (game.gameState === 'gameOver') {
                    break;
                }
            }
            
            gameData.endTime = Date.now();
            gameData.finalScore = game.score || 0;
            gameData.totalMoves = gameData.moves.length;
            gameData.duration = gameData.endTime - gameData.startTime;
            
            return gameData;
        }
        
        async function testMixedGameplay() {
            log('üîÑ Testing mixed gameplay score tracking...', 'info');
            document.getElementById('mixed-mode-card').className = 'game-mode-card testing';
            
            if (!game) {
                await initializeGame();
            }
            
            try {
                // Simulate mixed gameplay (human + AI)
                const gameData = simulateMixedGameplay(12);
                
                if (gameData) {
                    const scoreData = {
                        score: gameData.finalScore,
                        moves: gameData.totalMoves,
                        duration: gameData.duration,
                        playerType: 'mixed',
                        humanMoves: gameData.humanMoves,
                        aiMoves: gameData.aiMoves,
                        timestamp: Date.now(),
                        boardSize: 4
                    };
                    
                    // Save mixed game data
                    let mixedGames = JSON.parse(localStorage.getItem('mixedGameStats') || '[]');
                    mixedGames.push(scoreData);
                    localStorage.setItem('mixedGameStats', JSON.stringify(mixedGames));
                    
                    addTestResult('mixed-test-results', 'Mixed Score Save', true,
                                `Mixed game score ${gameData.finalScore} saved`);
                    
                    // Test mixed game analysis
                    const efficiency = gameData.aiMoves > 0 ? 
                        (gameData.finalScore / (gameData.humanMoves + gameData.aiMoves)).toFixed(2) : 0;
                    
                    addTestResult('mixed-test-results', 'Mixed Game Analysis', true,
                                `Human: ${gameData.humanMoves} moves, AI: ${gameData.aiMoves} moves, Efficiency: ${efficiency}`);
                    
                } else {
                    addTestResult('mixed-test-results', 'Mixed Gameplay Simulation', false,
                                'Failed to simulate mixed gameplay');
                }
            } catch (error) {
                addTestResult('mixed-test-results', 'Mixed Game Tracking', false,
                            `Mixed tracking failed: ${error.message}`);
            }
            
            document.getElementById('mixed-mode-card').className = 'game-mode-card active';
            updateProgress();
        }
        
        function simulateMixedGameplay(totalMoves) {
            if (!game) return null;
            
            const gameData = {
                startTime: Date.now(),
                moves: [],
                playerType: 'mixed',
                startScore: game.score || 0,
                humanMoves: 0,
                aiMoves: 0
            };
            
            game.resetGame();
            
            for (let i = 0; i < totalMoves; i++) {
                // Randomly choose between human and AI move (60% human, 40% AI)
                const isHumanMove = Math.random() > 0.4;
                let move = null;
                
                if (isHumanMove) {
                    // Simulate human move (random)
                    const possibleMoves = ['up', 'down', 'left', 'right'];
                    move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    gameData.humanMoves++;
                } else {
                    // Use AI move if available
                    if (game.enhancedAI) {
                        try {
                            move = game.enhancedAI.getBestMove();
                            gameData.aiMoves++;
                        } catch (e) {
                            // Fallback to human-like move
                            const possibleMoves = ['up', 'down', 'left', 'right'];
                            move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                            gameData.humanMoves++;
                        }
                    } else {
                        // No AI available, use human move
                        const possibleMoves = ['up', 'down', 'left', 'right'];
                        move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        gameData.humanMoves++;
                    }
                }
                
                if (move && game.canMove && game.canMove(move)) {
                    const oldScore = game.score || 0;
                    game.move(move);
                    const newScore = game.score || 0;
                    
                    gameData.moves.push({
                        move: move,
                        scoreGain: newScore - oldScore,
                        playerType: isHumanMove ? 'human' : 'ai'
                    });
                }
                
                if (game.gameState === 'gameOver') {
                    break;
                }
            }
            
            gameData.endTime = Date.now();
            gameData.finalScore = game.score || 0;
            gameData.totalMoves = gameData.moves.length;
            gameData.duration = gameData.endTime - gameData.startTime;
            
            return gameData;
        }
        
        function testScorePersistence() {
            log('üíæ Testing score persistence...', 'info');
            
            try {
                // Test data structure
                const testScore = {
                    score: 12345,
                    moves: 89,
                    duration: 300000,
                    playerType: 'test',
                    timestamp: Date.now(),
                    boardSize: 4
                };
                
                // Save and retrieve test
                localStorage.setItem('testScore', JSON.stringify(testScore));
                const retrieved = JSON.parse(localStorage.getItem('testScore'));
                
                if (retrieved && retrieved.score === testScore.score) {
                    updatePersistenceStats('Score Persistence', '‚úÖ Working');
                    log('‚úÖ Score persistence test passed', 'success');
                } else {
                    updatePersistenceStats('Score Persistence', '‚ùå Failed');
                    log('‚ùå Score persistence test failed', 'error');
                }
                
                // Clean up
                localStorage.removeItem('testScore');
                
            } catch (error) {
                updatePersistenceStats('Score Persistence', `‚ùå Error: ${error.message}`);
                log(`‚ùå Score persistence error: ${error.message}`, 'error');
            }
            
            updateProgress();
        }
        
        function testLeaderboardUpdates() {
            log('üèÜ Testing leaderboard updates...', 'info');
            
            try {
                // Generate test leaderboard data
                const testScores = [
                    { score: 15000, playerType: 'human', timestamp: Date.now() - 86400000 },
                    { score: 12000, playerType: 'ai', timestamp: Date.now() - 43200000 },
                    { score: 18000, playerType: 'mixed', timestamp: Date.now() - 7200000 },
                    { score: 9000, playerType: 'human', timestamp: Date.now() }
                ];
                
                localStorage.setItem('leaderboardTest', JSON.stringify(testScores));
                
                // Test sorting and filtering
                const retrieved = JSON.parse(localStorage.getItem('leaderboardTest'));
                const sorted = retrieved.sort((a, b) => b.score - a.score);
                
                if (sorted[0].score === 18000 && sorted.length === 4) {
                    updatePersistenceStats('Leaderboard Sorting', '‚úÖ Working');
                    log('‚úÖ Leaderboard sorting test passed', 'success');
                } else {
                    updatePersistenceStats('Leaderboard Sorting', '‚ùå Failed');
                    log('‚ùå Leaderboard sorting test failed', 'error');
                }
                
                // Test filtering by player type
                const humanOnly = retrieved.filter(s => s.playerType === 'human');
                const aiOnly = retrieved.filter(s => s.playerType === 'ai');
                const mixedOnly = retrieved.filter(s => s.playerType === 'mixed');
                
                if (humanOnly.length === 2 && aiOnly.length === 1 && mixedOnly.length === 1) {
                    updatePersistenceStats('Player Type Filtering', '‚úÖ Working');
                    log('‚úÖ Player type filtering test passed', 'success');
                } else {
                    updatePersistenceStats('Player Type Filtering', '‚ùå Failed');
                    log('‚ùå Player type filtering test failed', 'error');
                }
                
                // Clean up
                localStorage.removeItem('leaderboardTest');
                
            } catch (error) {
                updatePersistenceStats('Leaderboard Updates', `‚ùå Error: ${error.message}`);
                log(`‚ùå Leaderboard test error: ${error.message}`, 'error');
            }
            
            updateProgress();
        }
        
        function updatePersistenceStats(label, value) {
            const statsContainer = document.getElementById('persistence-stats');
            const statCard = document.createElement('div');
            statCard.className = 'stat-card';
            statCard.innerHTML = `<strong>${label}</strong><br>${value}`;
            statsContainer.appendChild(statCard);
        }
        
        function refreshLeaderboard() {
            log('üîÑ Refreshing leaderboard preview...', 'info');
            
            const leaderboardContainer = document.getElementById('leaderboard-preview');
            leaderboardContainer.innerHTML = '';
            
            try {
                // Collect all game data from different sources
                const humanGames = JSON.parse(localStorage.getItem('gameStats') || '[]');
                const aiGames = JSON.parse(localStorage.getItem('aiGameStats') || '[]');
                const mixedGames = JSON.parse(localStorage.getItem('mixedGameStats') || '[]');
                
                const allGames = [...humanGames, ...aiGames, ...mixedGames];
                const sortedGames = allGames.sort((a, b) => b.score - a.score).slice(0, 10);
                
                if (sortedGames.length === 0) {
                    leaderboardContainer.innerHTML = '<p>No scores found. Run some tests to generate data.</p>';
                    return;
                }
                
                leaderboardContainer.innerHTML = '<h4>Top 10 Scores (All Modes)</h4>';
                
                sortedGames.forEach((game, index) => {
                    const entry = document.createElement('div');
                    entry.className = 'score-entry';
                    
                    const playerTypeEmoji = {
                        'human': 'üë§',
                        'ai': 'ü§ñ',
                        'mixed': 'üîÑ'
                    };
                    
                    const date = new Date(game.timestamp).toLocaleDateString();
                    
                    entry.innerHTML = `
                        <span>#${index + 1} ${playerTypeEmoji[game.playerType] || '‚ùì'} ${game.playerType || 'Unknown'}</span>
                        <span><strong>${game.score || 0}</strong> pts</span>
                        <span>${date}</span>
                    `;
                    
                    leaderboardContainer.appendChild(entry);
                });
                
                log(`‚úÖ Leaderboard refreshed with ${sortedGames.length} entries`, 'success');
                
            } catch (error) {
                leaderboardContainer.innerHTML = `<p style="color: #f44;">Error loading leaderboard: ${error.message}</p>`;
                log(`‚ùå Leaderboard refresh error: ${error.message}`, 'error');
            }
            
            updateProgress();
        }
        
        function generateTestScores() {
            log('üìä Generating test score data...', 'info');
            
            try {
                const testData = {
                    human: [],
                    ai: [],
                    mixed: []
                };
                
                // Generate human scores
                for (let i = 0; i < 5; i++) {
                    testData.human.push({
                        score: Math.floor(Math.random() * 20000) + 1000,
                        moves: Math.floor(Math.random() * 100) + 20,
                        duration: Math.floor(Math.random() * 600000) + 60000,
                        playerType: 'human',
                        timestamp: Date.now() - Math.floor(Math.random() * 604800000),
                        boardSize: 4
                    });
                }
                
                // Generate AI scores
                for (let i = 0; i < 3; i++) {
                    testData.ai.push({
                        score: Math.floor(Math.random() * 25000) + 5000,
                        moves: Math.floor(Math.random() * 80) + 30,
                        duration: Math.floor(Math.random() * 300000) + 30000,
                        playerType: 'ai',
                        aiType: i % 2 === 0 ? 'enhanced-ai' : 'advanced-ai',
                        timestamp: Date.now() - Math.floor(Math.random() * 604800000),
                        boardSize: 4
                    });
                }
                
                // Generate mixed scores
                for (let i = 0; i < 2; i++) {
                    testData.mixed.push({
                        score: Math.floor(Math.random() * 30000) + 8000,
                        moves: Math.floor(Math.random() * 120) + 50,
                        duration: Math.floor(Math.random() * 900000) + 120000,
                        playerType: 'mixed',
                        humanMoves: Math.floor(Math.random() * 60) + 20,
                        aiMoves: Math.floor(Math.random() * 40) + 10,
                        timestamp: Date.now() - Math.floor(Math.random() * 604800000),
                        boardSize: 4
                    });
                }
                
                // Save test data
                localStorage.setItem('gameStats', JSON.stringify(testData.human));
                localStorage.setItem('aiGameStats', JSON.stringify(testData.ai));
                localStorage.setItem('mixedGameStats', JSON.stringify(testData.mixed));
                
                log('‚úÖ Test score data generated successfully', 'success');
                refreshLeaderboard();
                
            } catch (error) {
                log(`‚ùå Test data generation error: ${error.message}`, 'error');
            }
            
            updateProgress();
        }
        
        function clearAllScores() {
            log('üóëÔ∏è Clearing all test scores...', 'warning');
            
            try {
                localStorage.removeItem('gameStats');
                localStorage.removeItem('aiGameStats');
                localStorage.removeItem('mixedGameStats');
                localStorage.removeItem('leaderboardTest');
                
                document.getElementById('leaderboard-preview').innerHTML = '<p>All scores cleared.</p>';
                document.getElementById('persistence-stats').innerHTML = '';
                
                log('‚úÖ All test scores cleared', 'success');
                
            } catch (error) {
                log(`‚ùå Error clearing scores: ${error.message}`, 'error');
            }
        }
        
        function exportScoreData() {
            log('üìÅ Exporting score data...', 'info');
            
            try {
                const exportData = {
                    humanGames: JSON.parse(localStorage.getItem('gameStats') || '[]'),
                    aiGames: JSON.parse(localStorage.getItem('aiGameStats') || '[]'),
                    mixedGames: JSON.parse(localStorage.getItem('mixedGameStats') || '[]'),
                    testResults: testResults,
                    exportTimestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `fancy2048_score_test_results_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                log('‚úÖ Score data exported successfully', 'success');
                
            } catch (error) {
                log(`‚ùå Export error: ${error.message}`, 'error');
            }
        }
        
        function exportTestResults() {
            exportScoreData();
        }
        
        async function runFullScoreTest() {
            log('üöÄ Starting complete score dashboard test...', 'info');
            clearConsole();
            currentTestProgress = 0;
            
            // Clear previous test results
            document.getElementById('human-test-results').innerHTML = '';
            document.getElementById('ai-test-results').innerHTML = '';
            document.getElementById('mixed-test-results').innerHTML = '';
            document.getElementById('persistence-stats').innerHTML = '';
            
            const startTime = performance.now();
            
            // Initialize game
            await initializeGame();
            updateProgress();
            
            // Run all tests
            await testHumanGameplay();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testAIGameplay();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testMixedGameplay();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            testScorePersistence();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            testLeaderboardUpdates();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            generateTestScores();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            refreshLeaderboard();
            
            const endTime = performance.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);
            
            // Calculate results
            const totalTests = Object.keys(testResults).length;
            const passedTests = Object.values(testResults).filter(r => r.success).length;
            
            log(`üéâ Complete score dashboard test finished in ${duration}s`, 'success');
            log(`üìä Results: ${passedTests}/${totalTests} tests passed`, passedTests === totalTests ? 'success' : 'warning');
            
            if (passedTests === totalTests) {
                log('‚úÖ ALL SCORE TRACKING SYSTEMS WORKING CORRECTLY!', 'success');
            } else {
                log('‚ö†Ô∏è Some score tracking issues detected', 'warning');
            }
            
            // Update progress to 100%
            document.getElementById('overall-progress').style.width = '100%';
        }
        
        // Auto-initialize when page loads
        window.addEventListener('load', () => {
            log('üèÜ Score Dashboard Test Suite loaded', 'success');
            setTimeout(() => {
                log('Ready to test score tracking systems...', 'info');
                generateTestScores(); // Generate some initial test data
            }, 1000);
        });
    </script>
</body>
</html>